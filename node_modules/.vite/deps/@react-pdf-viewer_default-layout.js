import {
  require_lib as require_lib2
} from "./chunk-54MC3YR3.js";
import {
  require_lib
} from "./chunk-LDBIROIT.js";
import "./chunk-QZK72UOJ.js";
import {
  require_react
} from "./chunk-GPFM7T7K.js";
import {
  __commonJS
} from "./chunk-ETX6VGS4.js";

// node_modules/@react-pdf-viewer/attachment/lib/cjs/attachment.js
var require_attachment = __commonJS({
  "node_modules/@react-pdf-viewer/attachment/lib/cjs/attachment.js"(exports) {
    "use strict";
    var core = require_lib();
    var React = require_react();
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n.default = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespaceDefault(React);
    var getFileName = function(url) {
      var str = url.split("/").pop();
      return str ? str.split("#")[0].split("?")[0] : url;
    };
    var downloadFile = function(url, data) {
      var blobUrl = typeof data === "string" ? "" : URL.createObjectURL(new Blob([data], { type: "" }));
      var link = document.createElement("a");
      link.style.display = "none";
      link.href = blobUrl || url;
      link.setAttribute("download", getFileName(url));
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      if (blobUrl) {
        URL.revokeObjectURL(blobUrl);
      }
    };
    var AttachmentList = function(_a) {
      var files = _a.files;
      var containerRef = React__namespace.useRef();
      var l10n = React__namespace.useContext(core.LocalizationContext).l10n;
      var direction = React__namespace.useContext(core.ThemeContext).direction;
      var isRtl = direction === core.TextDirection.RightToLeft;
      var attachmentItemsRef = React__namespace.useRef([]);
      var clickDownloadLabel = l10n && l10n.attachment ? l10n.attachment.clickToDownload : "Click to download";
      var handleKeyDown = function(e) {
        switch (e.key) {
          case "ArrowDown":
            e.preventDefault();
            moveToItem(function(items, activeEle) {
              return items.indexOf(activeEle) + 1;
            });
            break;
          case "ArrowUp":
            e.preventDefault();
            moveToItem(function(items, activeEle) {
              return items.indexOf(activeEle) - 1;
            });
            break;
          case "End":
            e.preventDefault();
            moveToItem(function(items, _) {
              return items.length - 1;
            });
            break;
          case "Home":
            e.preventDefault();
            moveToItem(function(_, __) {
              return 0;
            });
            break;
        }
      };
      var moveToItem = function(getItemIndex) {
        var container = containerRef.current;
        var attachmentItems = [].slice.call(container.getElementsByClassName("rpv-attachment__item"));
        if (attachmentItems.length === 0) {
          return;
        }
        attachmentItems.forEach(function(item) {
          return item.setAttribute("tabindex", "-1");
        });
        var activeEle = document.activeElement;
        var targetIndex = Math.min(attachmentItems.length - 1, Math.max(0, getItemIndex(attachmentItems, activeEle)));
        var targetEle = attachmentItems[targetIndex];
        targetEle.setAttribute("tabindex", "0");
        targetEle.focus();
      };
      core.useIsomorphicLayoutEffect(function() {
        var container = containerRef.current;
        if (!container) {
          return;
        }
        var attachmentItems = [].slice.call(container.getElementsByClassName("rpv-attachment__item"));
        attachmentItemsRef.current = attachmentItems;
        if (attachmentItems.length > 0) {
          var firstItem = attachmentItems[0];
          firstItem.focus();
          firstItem.setAttribute("tabindex", "0");
        }
      }, []);
      return React__namespace.createElement("div", { "data-testid": "attachment__list", className: core.classNames({
        "rpv-attachment__list": true,
        "rpv-attachment__list--rtl": isRtl
      }), ref: containerRef, tabIndex: -1, onKeyDown: handleKeyDown }, files.map(function(file) {
        return React__namespace.createElement("button", { className: "rpv-attachment__item", key: file.fileName, tabIndex: -1, title: clickDownloadLabel, type: "button", onClick: function() {
          return downloadFile(file.fileName, file.data);
        } }, file.fileName);
      }));
    };
    var AttachmentLoader = function(_a) {
      var doc = _a.doc;
      var l10n = React__namespace.useContext(core.LocalizationContext).l10n;
      var direction = React__namespace.useContext(core.ThemeContext).direction;
      var isRtl = direction === core.TextDirection.RightToLeft;
      var noAttachmentLabel = l10n && l10n.attachment ? l10n.attachment.noAttachment : "There is no attachment";
      var _b = React__namespace.useState({
        files: [],
        isLoaded: false
      }), attachments = _b[0], setAttachments = _b[1];
      React__namespace.useEffect(function() {
        doc.getAttachments().then(function(response) {
          var files = response ? Object.keys(response).map(function(file) {
            return {
              data: response[file].content,
              fileName: response[file].filename
            };
          }) : [];
          setAttachments({
            files,
            isLoaded: true
          });
        });
      }, [doc]);
      return !attachments.isLoaded ? React__namespace.createElement(core.Spinner, null) : attachments.files.length === 0 ? React__namespace.createElement("div", { "data-testid": "attachment__empty", className: core.classNames({
        "rpv-attachment__empty": true,
        "rpv-attachment__empty--rtl": isRtl
      }) }, noAttachmentLabel) : React__namespace.createElement(AttachmentList, { files: attachments.files });
    };
    var AttachmentListWithStore = function(_a) {
      var store = _a.store;
      var _b = React__namespace.useState(store.get("doc")), currentDoc = _b[0], setCurrentDoc = _b[1];
      var handleDocumentChanged = function(doc) {
        setCurrentDoc(doc);
      };
      React__namespace.useEffect(function() {
        store.subscribe("doc", handleDocumentChanged);
        return function() {
          store.unsubscribe("doc", handleDocumentChanged);
        };
      }, []);
      return currentDoc ? React__namespace.createElement(AttachmentLoader, { doc: currentDoc }) : React__namespace.createElement(
        "div",
        { className: "rpv-attachment__loader" },
        React__namespace.createElement(core.Spinner, null)
      );
    };
    var attachmentPlugin = function() {
      var store = React__namespace.useMemo(function() {
        return core.createStore({});
      }, []);
      var AttachmentsDecorator = function() {
        return React__namespace.createElement(AttachmentListWithStore, { store });
      };
      return {
        onDocumentLoad: function(props) {
          store.update("doc", props.doc);
        },
        Attachments: AttachmentsDecorator
      };
    };
    exports.attachmentPlugin = attachmentPlugin;
  }
});

// node_modules/@react-pdf-viewer/attachment/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@react-pdf-viewer/attachment/lib/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_attachment();
    }
  }
});

// node_modules/@react-pdf-viewer/bookmark/lib/cjs/bookmark.js
var require_bookmark = __commonJS({
  "node_modules/@react-pdf-viewer/bookmark/lib/cjs/bookmark.js"(exports) {
    "use strict";
    var core = require_lib();
    var React = require_react();
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n.default = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespaceDefault(React);
    var DownArrowIcon = function() {
      return React__namespace.createElement(
        core.Icon,
        { size: 16 },
        React__namespace.createElement("path", { d: "M6.427,8.245A.5.5,0,0,1,6.862,7.5H17.138a.5.5,0,0,1,.435.749l-5.139,9a.5.5,0,0,1-.868,0Z" })
      );
    };
    var RightArrowIcon = function() {
      return React__namespace.createElement(
        core.Icon,
        { size: 16 },
        React__namespace.createElement("path", { d: "M9.248,17.572a.5.5,0,0,1-.748-.434V6.862a.5.5,0,0,1,.748-.434l8.992,5.138a.5.5,0,0,1,0,.868Z" })
      );
    };
    var shouldBeCollapsed = function(bookmark) {
      var count = bookmark.count, items = bookmark.items;
      if (count >= 0) {
        return false;
      }
      var numSubItems = items.length;
      if (numSubItems === 0) {
        return false;
      }
      var subItems = items.concat([]);
      while (subItems.length > 0) {
        var firstChild = subItems.shift();
        var children = firstChild.items;
        if (firstChild.count && children && firstChild.count > 0 && children.length > 0) {
          numSubItems += children.length;
          subItems = subItems.concat(children);
        }
      }
      return Math.abs(count) === numSubItems;
    };
    var BookmarkItem = function(_a) {
      var bookmark = _a.bookmark, depth = _a.depth, doc = _a.doc, index = _a.index, isBookmarkExpanded = _a.isBookmarkExpanded, numberOfSiblings = _a.numberOfSiblings, pathFromRoot = _a.pathFromRoot, renderBookmarkItem = _a.renderBookmarkItem, store = _a.store, onJumpToDest = _a.onJumpToDest;
      var path = pathFromRoot ? "".concat(pathFromRoot, ".").concat(index) : "".concat(index);
      var defaultIsCollapsed = React__namespace.useMemo(function() {
        return shouldBeCollapsed(bookmark);
      }, [bookmark]);
      var bookmarkExpandedMap = store.get("bookmarkExpandedMap");
      var defaultExpanded = isBookmarkExpanded ? isBookmarkExpanded({ bookmark, doc, depth, index }) : bookmarkExpandedMap.has(path) ? bookmarkExpandedMap.get(path) : !defaultIsCollapsed;
      var _b = React__namespace.useState(defaultExpanded), expanded = _b[0], setExpanded = _b[1];
      var hasSubItems = bookmark.items && bookmark.items.length > 0;
      var toggleSubItems = function() {
        var newState = !expanded;
        store.updateCurrentValue("bookmarkExpandedMap", function(currentValue) {
          return currentValue.set(path, newState);
        });
        setExpanded(newState);
      };
      var clickBookmark = function() {
        if (hasSubItems && bookmark.dest) {
          onJumpToDest(bookmark.dest);
        }
      };
      var clickItem = function() {
        if (!hasSubItems && bookmark.dest) {
          onJumpToDest(bookmark.dest);
        }
      };
      var defaultRenderItem = function(onClickItem, children) {
        return React__namespace.createElement("div", { className: "rpv-bookmark__item", style: {
          paddingLeft: "".concat(depth * 1.25, "rem")
        }, onClick: onClickItem }, children);
      };
      var defaultRenderToggle = function(expandIcon, collapseIcon) {
        return hasSubItems ? React__namespace.createElement("span", { className: "rpv-bookmark__toggle", "data-testid": "bookmark__toggle-".concat(depth, "-").concat(index), onClick: toggleSubItems }, expanded ? expandIcon : collapseIcon) : React__namespace.createElement("span", { className: "rpv-bookmark__toggle" });
      };
      var defaultRenderTitle = function(onClickBookmark) {
        return bookmark.url ? React__namespace.createElement("a", { className: "rpv-bookmark__title", href: bookmark.url, rel: "noopener noreferrer nofollow", target: bookmark.newWindow ? "_blank" : "" }, bookmark.title) : React__namespace.createElement("div", { className: "rpv-bookmark__title", "aria-label": bookmark.title, onClick: onClickBookmark }, bookmark.title);
      };
      return React__namespace.createElement(
        "li",
        { "aria-expanded": expanded ? "true" : "false", "aria-label": bookmark.title, "aria-level": depth + 1, "aria-posinset": index + 1, "aria-setsize": numberOfSiblings, role: "treeitem", tabIndex: -1 },
        renderBookmarkItem ? renderBookmarkItem({
          bookmark,
          depth,
          hasSubItems,
          index,
          isExpanded: expanded,
          path,
          defaultRenderItem,
          defaultRenderTitle,
          defaultRenderToggle,
          onClickItem: clickItem,
          onClickTitle: clickBookmark,
          onToggleSubItems: toggleSubItems
        }) : defaultRenderItem(clickItem, React__namespace.createElement(
          React__namespace.Fragment,
          null,
          defaultRenderToggle(React__namespace.createElement(DownArrowIcon, null), React__namespace.createElement(RightArrowIcon, null)),
          defaultRenderTitle(clickBookmark)
        )),
        hasSubItems && expanded && React__namespace.createElement(BookmarkList, { bookmarks: bookmark.items, depth: depth + 1, doc, isBookmarkExpanded, isRoot: false, pathFromRoot: path, renderBookmarkItem, store, onJumpToDest })
      );
    };
    var BookmarkList = function(_a) {
      var bookmarks = _a.bookmarks, _b = _a.depth, depth = _b === void 0 ? 0 : _b, doc = _a.doc, isBookmarkExpanded = _a.isBookmarkExpanded, isRoot = _a.isRoot, pathFromRoot = _a.pathFromRoot, renderBookmarkItem = _a.renderBookmarkItem, store = _a.store, onJumpToDest = _a.onJumpToDest;
      return React__namespace.createElement("ul", { className: "rpv-bookmark__list", role: isRoot ? "tree" : "group", tabIndex: -1 }, bookmarks.map(function(bookmark, index) {
        return React__namespace.createElement(BookmarkItem, { bookmark, depth, doc, index, isBookmarkExpanded, key: index, numberOfSiblings: bookmarks.length, pathFromRoot, renderBookmarkItem, store, onJumpToDest });
      }));
    };
    var Toggle;
    (function(Toggle2) {
      Toggle2[Toggle2["Collapse"] = 0] = "Collapse";
      Toggle2[Toggle2["Expand"] = 1] = "Expand";
    })(Toggle || (Toggle = {}));
    var BookmarkListRoot = function(_a) {
      var bookmarks = _a.bookmarks, doc = _a.doc, isBookmarkExpanded = _a.isBookmarkExpanded, renderBookmarkItem = _a.renderBookmarkItem, store = _a.store, onJumpToDest = _a.onJumpToDest;
      var containerRef = React__namespace.useRef();
      var jumpToDest = function(dest) {
        core.getDestination(doc, dest).then(function(target) {
          var pageIndex = target.pageIndex, bottomOffset = target.bottomOffset, leftOffset = target.leftOffset, scaleTo = target.scaleTo;
          onJumpToDest(pageIndex, bottomOffset, leftOffset, scaleTo);
        });
      };
      var handleKeyDown = function(e) {
        var container = containerRef.current;
        if (!container || !(e.target instanceof HTMLElement) || !container.contains(e.target)) {
          return;
        }
        switch (e.key) {
          case "ArrowDown":
            e.preventDefault();
            moveToItem(function(bookmarkElements, activeEle) {
              return bookmarkElements.indexOf(activeEle) + 1;
            });
            break;
          case "ArrowLeft":
            e.preventDefault();
            toggle(Toggle.Collapse);
            break;
          case "ArrowRight":
            e.preventDefault();
            toggle(Toggle.Expand);
            break;
          case "ArrowUp":
            e.preventDefault;
            moveToItem(function(bookmarkElements, activeEle) {
              return bookmarkElements.indexOf(activeEle) - 1;
            });
            break;
          case "End":
            e.preventDefault();
            moveToItem(function(bookmarkElements, _) {
              return bookmarkElements.length - 1;
            });
            break;
          case " ":
          case "Enter":
          case "Space":
            e.preventDefault();
            clickBookmark();
            break;
          case "Home":
            e.preventDefault();
            moveToItem(function(_, __) {
              return 0;
            });
            break;
        }
      };
      var clickBookmark = function() {
        var closestItem = document.activeElement.closest(".rpv-bookmark__item");
        var titleEle = closestItem.querySelector(".rpv-bookmark__title");
        if (titleEle) {
          titleEle.click();
        }
      };
      var moveToItem = function(getItemIndex) {
        var container = containerRef.current;
        var bookmarkElements = [].slice.call(container.getElementsByClassName("rpv-bookmark__item"));
        if (bookmarkElements.length === 0) {
          return;
        }
        var activeEle = document.activeElement;
        var targetIndex = Math.min(bookmarkElements.length - 1, Math.max(0, getItemIndex(bookmarkElements, activeEle)));
        var targetEle = bookmarkElements[targetIndex];
        activeEle.setAttribute("tabindex", "-1");
        targetEle.setAttribute("tabindex", "0");
        targetEle.focus();
      };
      var toggle = function(toggle2) {
        var container = containerRef.current;
        var bookmarkElements = [].slice.call(container.getElementsByClassName("rpv-bookmark__item"));
        if (bookmarkElements.length === 0) {
          return;
        }
        var closestItem = document.activeElement.closest(".rpv-bookmark__item");
        var expanedAttribute = toggle2 === Toggle.Collapse ? "true" : "false";
        if (closestItem && closestItem.parentElement.getAttribute("aria-expanded") === expanedAttribute) {
          var toggleEle = closestItem.querySelector(".rpv-bookmark__toggle");
          if (toggleEle) {
            toggleEle.click();
          }
        }
      };
      React__namespace.useEffect(function() {
        document.addEventListener("keydown", handleKeyDown);
        return function() {
          document.removeEventListener("keydown", handleKeyDown);
        };
      }, []);
      React__namespace.useEffect(function() {
        var container = containerRef.current;
        if (!container) {
          return;
        }
        var bookmarkElements = [].slice.call(container.getElementsByClassName("rpv-bookmark__item"));
        if (bookmarkElements.length > 0) {
          bookmarkElements[0].focus();
          bookmarkElements[0].setAttribute("tabindex", "0");
        }
      }, []);
      return React__namespace.createElement(
        "div",
        { ref: containerRef },
        React__namespace.createElement(BookmarkList, { bookmarks, depth: 0, doc, isBookmarkExpanded, isRoot: true, pathFromRoot: "", renderBookmarkItem, store, onJumpToDest: jumpToDest })
      );
    };
    var BookmarkLoader = function(_a) {
      var doc = _a.doc, isBookmarkExpanded = _a.isBookmarkExpanded, renderBookmarkItem = _a.renderBookmarkItem, store = _a.store, onJumpToDest = _a.onJumpToDest;
      var l10n = React__namespace.useContext(core.LocalizationContext).l10n;
      var direction = React__namespace.useContext(core.ThemeContext).direction;
      var isRtl = direction === core.TextDirection.RightToLeft;
      var _b = React__namespace.useState({
        isLoaded: false,
        items: []
      }), bookmarks = _b[0], setBookmarks = _b[1];
      React__namespace.useEffect(function() {
        setBookmarks({
          isLoaded: false,
          items: []
        });
        doc.getOutline().then(function(outline) {
          setBookmarks({
            isLoaded: true,
            items: outline || []
          });
        });
      }, [doc]);
      return !bookmarks.isLoaded ? React__namespace.createElement(
        "div",
        { className: "rpv-bookmark__loader" },
        React__namespace.createElement(core.Spinner, null)
      ) : bookmarks.items.length === 0 ? React__namespace.createElement("div", { "data-testid": "bookmark__empty", className: core.classNames({
        "rpv-bookmark__empty": true,
        "rpv-bookmark__empty--rtl": isRtl
      }) }, l10n && l10n.bookmark ? l10n.bookmark.noBookmark : "There is no bookmark") : React__namespace.createElement(
        "div",
        { "data-testid": "bookmark__container", className: core.classNames({
          "rpv-bookmark__container": true,
          "rpv-bookmark__container--rtl": isRtl
        }) },
        React__namespace.createElement(BookmarkListRoot, { bookmarks: bookmarks.items, doc, isBookmarkExpanded, renderBookmarkItem, store, onJumpToDest })
      );
    };
    var BookmarkListWithStore = function(_a) {
      var isBookmarkExpanded = _a.isBookmarkExpanded, renderBookmarkItem = _a.renderBookmarkItem, store = _a.store;
      var _b = React__namespace.useState(store.get("doc")), currentDoc = _b[0], setCurrentDoc = _b[1];
      var handleDocumentChanged = function(doc) {
        setCurrentDoc(doc);
      };
      var jump = function(pageIndex, bottomOffset, leftOffset, scaleTo) {
        var jumpToDestination = store.get("jumpToDestination");
        if (jumpToDestination) {
          jumpToDestination(pageIndex, bottomOffset, leftOffset, scaleTo);
        }
      };
      React__namespace.useEffect(function() {
        store.subscribe("doc", handleDocumentChanged);
        return function() {
          store.unsubscribe("doc", handleDocumentChanged);
        };
      }, []);
      return currentDoc ? React__namespace.createElement(BookmarkLoader, { doc: currentDoc, isBookmarkExpanded, renderBookmarkItem, store, onJumpToDest: jump }) : React__namespace.createElement(
        "div",
        { className: "rpv-bookmark__loader" },
        React__namespace.createElement(core.Spinner, null)
      );
    };
    var bookmarkPlugin = function() {
      var store = React__namespace.useMemo(function() {
        return core.createStore({
          bookmarkExpandedMap: /* @__PURE__ */ new Map()
        });
      }, []);
      var BookmarksDecorator = function(props) {
        return React__namespace.createElement(BookmarkListWithStore, { isBookmarkExpanded: props === null || props === void 0 ? void 0 : props.isBookmarkExpanded, renderBookmarkItem: props === null || props === void 0 ? void 0 : props.renderBookmarkItem, store });
      };
      return {
        install: function(pluginFunctions) {
          store.update("jumpToDestination", pluginFunctions.jumpToDestination);
        },
        onDocumentLoad: function(props) {
          store.update("doc", props.doc);
        },
        Bookmarks: BookmarksDecorator
      };
    };
    exports.DownArrowIcon = DownArrowIcon;
    exports.RightArrowIcon = RightArrowIcon;
    exports.bookmarkPlugin = bookmarkPlugin;
  }
});

// node_modules/@react-pdf-viewer/bookmark/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@react-pdf-viewer/bookmark/lib/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_bookmark();
    }
  }
});

// node_modules/@react-pdf-viewer/thumbnail/lib/cjs/thumbnail.js
var require_thumbnail = __commonJS({
  "node_modules/@react-pdf-viewer/thumbnail/lib/cjs/thumbnail.js"(exports) {
    "use strict";
    var core = require_lib();
    var React = require_react();
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n.default = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespaceDefault(React);
    var __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var CoverInner = function(_a) {
      var doc = _a.doc, getPageIndex = _a.getPageIndex, renderSpinner = _a.renderSpinner, store = _a.store;
      var numPages = doc.numPages;
      var targetPage = getPageIndex ? getPageIndex({ numPages }) : 0;
      var normalizePage = Math.max(0, Math.min(targetPage, numPages - 1));
      var initialPagesRotation = store.get("pagesRotation") || /* @__PURE__ */ new Map();
      var initialTargetPageRotation = initialPagesRotation.has(normalizePage) ? initialPagesRotation.get(normalizePage) : 0;
      var _b = React__namespace.useState(""), src = _b[0], setSrc = _b[1];
      var isMounted = core.useIsMounted();
      var renderTask = React__namespace.useRef();
      var _c = React__namespace.useState(store.get("rotation") || 0), rotation = _c[0], setRotation = _c[1];
      var _d = React__namespace.useState(initialTargetPageRotation), pageRotation = _d[0], setPageRotation = _d[1];
      var _e = React__namespace.useState(false), isVisible = _e[0], setVisible = _e[1];
      var handlePagesRotationChanged = function(rotations) {
        var pageRotation2 = rotations.has(normalizePage) ? rotations.get(normalizePage) : 0;
        setPageRotation(pageRotation2);
      };
      var handleRotationChanged = function(currentRotation) {
        setRotation(currentRotation);
      };
      var handleVisibilityChanged = function(params) {
        setVisible(params.isVisible);
      };
      var containerRef = core.useIntersectionObserver({
        onVisibilityChanged: handleVisibilityChanged
      });
      React__namespace.useEffect(function() {
        if (!isVisible) {
          return;
        }
        var containerEle = containerRef.current;
        if (!containerEle) {
          return;
        }
        setSrc("");
        core.getPage(doc, normalizePage).then(function(page) {
          var viewport = page.getViewport({ scale: 1 });
          var viewportRotation = viewport.rotation;
          var rotationValue = (viewportRotation + rotation + pageRotation) % 360;
          var isVertical = Math.abs(rotation + pageRotation) % 180 === 0;
          var w = isVertical ? viewport.width : viewport.height;
          var h = isVertical ? viewport.height : viewport.width;
          var canvas = document.createElement("canvas");
          var canvasContext = canvas.getContext("2d", { alpha: false });
          var containerWidth = containerEle.clientWidth;
          var containerHeight = containerEle.clientHeight;
          var scaled = Math.min(containerWidth / w, containerHeight / h);
          var canvasWidth = scaled * w;
          var canvasHeight = scaled * h;
          canvas.height = canvasHeight;
          canvas.width = canvasWidth;
          canvas.style.opacity = "0";
          var renderViewport = page.getViewport({
            rotation: rotationValue,
            scale: scaled
          });
          renderTask.current = page.render({ canvasContext, viewport: renderViewport });
          renderTask.current.promise.then(function() {
            isMounted.current && setSrc(canvas.toDataURL());
            canvas.width = 0;
            canvas.height = 0;
          }, function() {
          });
        });
      }, [pageRotation, isVisible]);
      React__namespace.useEffect(function() {
        store.subscribe("pagesRotation", handlePagesRotationChanged);
        store.subscribe("rotation", handleRotationChanged);
        return function() {
          store.unsubscribe("pagesRotation", handlePagesRotationChanged);
          store.unsubscribe("rotation", handleRotationChanged);
        };
      }, []);
      React__namespace.useEffect(function() {
        return function() {
          var _a2;
          (_a2 = renderTask.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
        };
      }, []);
      return React__namespace.createElement("div", { ref: containerRef, className: "rpv-thumbnail__cover-inner", "data-testid": "thumbnail__cover-inner" }, src ? React__namespace.createElement("img", { className: "rpv-thumbnail__cover-image", "data-testid": "thumbnail__cover-image", src }) : React__namespace.createElement("div", { className: "rpv-thumbnail__cover-loader", "data-testid": "thumbnail__cover-loader" }, renderSpinner ? renderSpinner() : React__namespace.createElement(core.Spinner, null)));
    };
    var Cover = function(_a) {
      var getPageIndex = _a.getPageIndex, renderSpinner = _a.renderSpinner, store = _a.store;
      var _b = React__namespace.useState(store.get("doc")), currentDoc = _b[0], setCurrentDoc = _b[1];
      var handleDocumentChanged = function(doc) {
        setCurrentDoc(doc);
      };
      React__namespace.useEffect(function() {
        store.subscribe("doc", handleDocumentChanged);
        return function() {
          store.unsubscribe("doc", handleDocumentChanged);
        };
      }, []);
      return React__namespace.createElement("div", { className: "rpv-thumbnail__cover" }, currentDoc ? React__namespace.createElement(CoverInner, { doc: currentDoc, getPageIndex, renderSpinner, store }) : React__namespace.createElement("div", { className: "rpv-thumbnail__cover-loader" }, renderSpinner ? renderSpinner() : React__namespace.createElement(core.Spinner, null)));
    };
    var defaultSpinner = function() {
      return React__namespace.createElement(core.Spinner, null);
    };
    var SpinnerContext = React__namespace.createContext({
      renderSpinner: defaultSpinner
    });
    var FetchLabels = function(_a) {
      var children = _a.children, doc = _a.doc;
      var isMounted = core.useIsMounted();
      var _b = React__namespace.useState({
        loading: true,
        labels: []
      }), status = _b[0], setStatus = _b[1];
      React__namespace.useEffect(function() {
        doc.getPageLabels().then(function(result) {
          isMounted.current && setStatus({ loading: false, labels: result || [] });
        });
      }, [doc.loadingTask.docId]);
      return status.loading ? React__namespace.createElement(React__namespace.Fragment, null) : children(status.labels);
    };
    var scrollToBeVisible = function(ele, container) {
      var top = ele.getBoundingClientRect().top - container.getBoundingClientRect().top;
      var eleHeight = ele.clientHeight;
      var containerHeight = container.clientHeight;
      if (top < 0) {
        container.scrollTop += top;
        return;
      }
      if (top + eleHeight <= containerHeight) {
        return;
      }
      container.scrollTop += top + eleHeight - containerHeight;
    };
    var ThumbnailItem = function(_a) {
      var page = _a.page, pageHeight = _a.pageHeight, pageIndex = _a.pageIndex, pageWidth = _a.pageWidth, rotation = _a.rotation, thumbnailHeight = _a.thumbnailHeight, thumbnailWidth = _a.thumbnailWidth, onRenderCompleted = _a.onRenderCompleted;
      var l10n = React__namespace.useContext(core.LocalizationContext).l10n;
      var renderTask = React__namespace.useRef();
      var _b = React__namespace.useState(""), src = _b[0], setSrc = _b[1];
      var thumbnailLabel = l10n && l10n.thumbnail ? l10n.thumbnail.thumbnailLabel : "Thumbnail of page {{pageIndex}}";
      React__namespace.useEffect(function() {
        var task = renderTask.current;
        if (task) {
          task.cancel();
        }
        var canvas = document.createElement("canvas");
        var canvasContext = canvas.getContext("2d", { alpha: false });
        var w = thumbnailWidth;
        var h = w / (pageWidth / pageHeight);
        var scale = w / pageWidth;
        canvas.height = h;
        canvas.width = w;
        canvas.style.height = "".concat(h, "px");
        canvas.style.width = "".concat(w, "px");
        var viewport = page.getViewport({ rotation, scale });
        renderTask.current = page.render({ canvasContext, viewport });
        renderTask.current.promise.then(function() {
          setSrc(canvas.toDataURL());
          onRenderCompleted(pageIndex);
        }, function() {
          onRenderCompleted(pageIndex);
        });
        return function() {
          var _a2;
          (_a2 = renderTask.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
        };
      }, [rotation]);
      return !src ? React__namespace.useContext(SpinnerContext).renderSpinner() : React__namespace.createElement("img", { "aria-label": thumbnailLabel.replace("{{pageIndex}}", "".concat(pageIndex + 1)), src, height: "".concat(thumbnailHeight, "px"), width: "".concat(thumbnailWidth, "px") });
    };
    var ThumbnailContainer = function(_a) {
      var doc = _a.doc, pageHeight = _a.pageHeight, pageIndex = _a.pageIndex, pageRotation = _a.pageRotation, pageWidth = _a.pageWidth, rotation = _a.rotation, shouldRender = _a.shouldRender, thumbnailWidth = _a.thumbnailWidth, onRenderCompleted = _a.onRenderCompleted, onVisibilityChanged = _a.onVisibilityChanged;
      var isMounted = core.useIsMounted();
      var _b = React__namespace.useState({
        height: pageHeight,
        page: null,
        viewportRotation: 0,
        width: pageWidth
      }), pageSize = _b[0], setPageSize = _b[1];
      var page = pageSize.page, height = pageSize.height, width = pageSize.width;
      var scale = width / height;
      var isVertical = Math.abs(rotation + pageRotation) % 180 === 0;
      var w = isVertical ? thumbnailWidth : thumbnailWidth / scale;
      var h = isVertical ? thumbnailWidth / scale : thumbnailWidth;
      React__namespace.useEffect(function() {
        if (shouldRender) {
          core.getPage(doc, pageIndex).then(function(pdfPage) {
            var viewport = pdfPage.getViewport({ scale: 1 });
            isMounted.current && setPageSize({
              height: viewport.height,
              page: pdfPage,
              viewportRotation: viewport.rotation,
              width: viewport.width
            });
          });
        }
      }, [shouldRender]);
      var rotationNumber = (pageSize.viewportRotation + rotation + pageRotation) % 360;
      var containerRef = core.useIntersectionObserver({
        onVisibilityChanged: function(visibility) {
          onVisibilityChanged(pageIndex, visibility);
        }
      });
      return React__namespace.createElement("div", { className: "rpv-thumbnail__container", "data-testid": "thumbnail__container-".concat(pageIndex), ref: containerRef, style: {
        height: "".concat(h, "px"),
        width: "".concat(w, "px")
      } }, !page ? React__namespace.useContext(SpinnerContext).renderSpinner() : React__namespace.createElement(ThumbnailItem, { page, pageHeight: isVertical ? height : width, pageIndex, pageWidth: isVertical ? width : height, rotation: rotationNumber, thumbnailHeight: h, thumbnailWidth: w, onRenderCompleted }));
    };
    var ThumbnailList = function(_a) {
      var currentPage = _a.currentPage, doc = _a.doc, labels = _a.labels, pagesRotation = _a.pagesRotation, pageHeight = _a.pageHeight, pageWidth = _a.pageWidth, renderCurrentPageLabel = _a.renderCurrentPageLabel, renderThumbnailItem = _a.renderThumbnailItem, rotatedPage = _a.rotatedPage, rotation = _a.rotation, thumbnailWidth = _a.thumbnailWidth, onJumpToPage = _a.onJumpToPage, onRotatePage = _a.onRotatePage;
      var numPages = doc.numPages;
      var docId = doc.loadingTask.docId;
      var containerRef = React__namespace.useRef(null);
      var thumbnailsRef = React__namespace.useRef([]);
      var _b = React__namespace.useState(currentPage), currentFocused = _b[0], setCurrentFocused = _b[1];
      var direction = React__namespace.useContext(core.ThemeContext).direction;
      var isRtl = direction === core.TextDirection.RightToLeft;
      var _c = React__namespace.useState(-1), renderPageIndex = _c[0], setRenderPageIndex = _c[1];
      var isMounted = core.useIsMounted();
      var hasRenderingThumbnailRef = React__namespace.useRef(false);
      var renderQueue = core.useRenderQueue({ doc });
      var pageIndexes = React__namespace.useMemo(function() {
        return Array(numPages).fill(0).map(function(_, pageIndex) {
          return pageIndex;
        });
      }, [docId]);
      var handleKeyDown = function(e) {
        switch (e.key) {
          case "ArrowDown":
            activateNextItem();
            break;
          case "ArrowUp":
            activatePreviousItem();
            break;
          case "Enter":
            jumpToFocusedPage();
            break;
        }
      };
      var activateNextItem = function() {
        var container = containerRef.current;
        if (!container) {
          return;
        }
        var items = thumbnailsRef.current;
        var nextItem = currentFocused + 1;
        if (nextItem < items.length) {
          if (currentFocused >= 0) {
            items[currentFocused].setAttribute("tabindex", "-1");
          }
          setCurrentFocused(nextItem);
        }
      };
      var activatePreviousItem = function() {
        var container = containerRef.current;
        if (!container) {
          return;
        }
        var items = thumbnailsRef.current;
        var prevItem = currentFocused - 1;
        if (prevItem >= 0) {
          if (currentFocused >= 0) {
            items[currentFocused].setAttribute("tabindex", "-1");
          }
          setCurrentFocused(prevItem);
        }
      };
      var jumpToFocusedPage = function() {
        if (currentFocused >= 0 && currentFocused < numPages) {
          onJumpToPage(currentFocused);
        }
      };
      core.useIsomorphicLayoutEffect(function() {
        var container = containerRef.current;
        if (!container) {
          return;
        }
        thumbnailsRef.current = Array.from(container.querySelectorAll(".rpv-thumbnail__item"));
      }, []);
      React__namespace.useEffect(function() {
        var thumbnails = thumbnailsRef.current;
        if (thumbnails.length === 0 || currentFocused < 0 || currentFocused > thumbnails.length) {
          return;
        }
        var thumbnailEle = thumbnails[currentFocused];
        thumbnailEle.setAttribute("tabindex", "0");
        thumbnailEle.focus();
      }, [currentFocused]);
      core.useIsomorphicLayoutEffect(function() {
        var container = containerRef.current;
        if (container) {
          var thumbnailNodes = container.children;
          if (currentPage < thumbnailNodes.length) {
            scrollToBeVisible(thumbnailNodes.item(currentPage), container);
          }
        }
      }, [currentPage]);
      var handleRenderCompleted = React__namespace.useCallback(function(pageIndex) {
        if (isMounted.current) {
          renderQueue.markRendered(pageIndex);
          hasRenderingThumbnailRef.current = false;
          renderNextThumbnail();
        }
      }, [docId]);
      var handleVisibilityChanged = React__namespace.useCallback(function(pageIndex, visibility) {
        visibility.isVisible ? renderQueue.setVisibility(pageIndex, visibility.ratio) : renderQueue.setOutOfRange(pageIndex);
        renderNextThumbnail();
      }, [docId]);
      var renderNextThumbnail = React__namespace.useCallback(function() {
        if (hasRenderingThumbnailRef.current) {
          return;
        }
        var nextPage = renderQueue.getHighestPriorityPage();
        if (nextPage > -1) {
          renderQueue.markRendering(nextPage);
          hasRenderingThumbnailRef.current = true;
          setRenderPageIndex(nextPage);
        }
      }, [docId]);
      React__namespace.useEffect(function() {
        if (rotatedPage >= 0) {
          renderQueue.markRendering(rotatedPage);
          hasRenderingThumbnailRef.current = true;
          setRenderPageIndex(rotatedPage);
        }
      }, [docId, rotatedPage]);
      return React__namespace.createElement("div", { ref: containerRef, "data-testid": "thumbnail__list", className: core.classNames({
        "rpv-thumbnail__list": true,
        "rpv-thumbnail__list--rtl": isRtl
      }), onKeyDown: handleKeyDown }, pageIndexes.map(function(pageIndex) {
        var key = "".concat(doc.loadingTask.docId, "___").concat(pageIndex);
        var pageLabel = labels.length === numPages ? labels[pageIndex] : "".concat(pageIndex + 1);
        var label = renderCurrentPageLabel ? renderCurrentPageLabel({ currentPage, pageIndex, numPages, pageLabel }) : pageLabel;
        var pageRotation = pagesRotation.has(pageIndex) ? pagesRotation.get(pageIndex) : 0;
        var thumbnail = React__namespace.createElement(ThumbnailContainer, { doc, pageHeight, pageIndex, pageRotation, pageWidth, rotation, shouldRender: renderPageIndex === pageIndex, thumbnailWidth, onRenderCompleted: handleRenderCompleted, onVisibilityChanged: handleVisibilityChanged });
        return renderThumbnailItem ? renderThumbnailItem({
          currentPage,
          key,
          numPages,
          pageIndex,
          renderPageLabel: React__namespace.createElement(React__namespace.Fragment, null, label),
          renderPageThumbnail: thumbnail,
          onJumpToPage: function() {
            return onJumpToPage(pageIndex);
          },
          onRotatePage: function(direction2) {
            return onRotatePage(pageIndex, direction2);
          }
        }) : React__namespace.createElement(
          "div",
          { key },
          React__namespace.createElement("div", { className: core.classNames({
            "rpv-thumbnail__item": true,
            "rpv-thumbnail__item--selected": currentPage === pageIndex
          }), role: "button", tabIndex: currentPage === pageIndex ? 0 : -1, onClick: function() {
            return onJumpToPage(pageIndex);
          } }, thumbnail),
          React__namespace.createElement("div", { "data-testid": "thumbnail__label-".concat(pageIndex), className: "rpv-thumbnail__label" }, label)
        );
      }));
    };
    var ThumbnailListWithStore = function(_a) {
      var renderCurrentPageLabel = _a.renderCurrentPageLabel, renderThumbnailItem = _a.renderThumbnailItem, store = _a.store, thumbnailWidth = _a.thumbnailWidth;
      var _b = React__namespace.useState(store.get("doc")), currentDoc = _b[0], setCurrentDoc = _b[1];
      var _c = React__namespace.useState(store.get("currentPage") || 0), currentPage = _c[0], setCurrentPage = _c[1];
      var _d = React__namespace.useState(store.get("pageHeight") || 0), pageHeight = _d[0], setPageHeight = _d[1];
      var _e = React__namespace.useState(store.get("pageWidth") || 0), pageWidth = _e[0], setPageWidth = _e[1];
      var _f = React__namespace.useState(store.get("rotation") || 0), rotation = _f[0], setRotation = _f[1];
      var _g = React__namespace.useState(store.get("pagesRotation") || /* @__PURE__ */ new Map()), pagesRotation = _g[0], setPagesRotation = _g[1];
      var _h = React__namespace.useState(store.get("rotatedPage") || -1), rotatedPage = _h[0], setRotatedPage = _h[1];
      var handleCurrentPageChanged = function(currentPageIndex) {
        setCurrentPage(currentPageIndex);
      };
      var handleDocumentChanged = function(doc) {
        setCurrentDoc(doc);
      };
      var handlePageHeightChanged = function(height) {
        setPageHeight(height);
      };
      var handlePageWidthChanged = function(width) {
        setPageWidth(width);
      };
      var handleRotationChanged = function(currentRotation) {
        setRotation(currentRotation);
      };
      var handlePagesRotationChanged = function(rotations) {
        setPagesRotation(rotations);
      };
      var handleRotatedPage = function(rotatedPage2) {
        setRotatedPage(rotatedPage2);
      };
      var jump = function(pageIndex) {
        var jumpToPage = store.get("jumpToPage");
        if (jumpToPage) {
          jumpToPage(pageIndex);
        }
      };
      var rotatePage = function(pageIndex, direction) {
        store.get("rotatePage")(pageIndex, direction);
      };
      React__namespace.useEffect(function() {
        store.subscribe("doc", handleDocumentChanged);
        store.subscribe("pageHeight", handlePageHeightChanged);
        store.subscribe("pageWidth", handlePageWidthChanged);
        store.subscribe("rotatedPage", handleRotatedPage);
        store.subscribe("rotation", handleRotationChanged);
        store.subscribe("pagesRotation", handlePagesRotationChanged);
        return function() {
          store.unsubscribe("doc", handleDocumentChanged);
          store.unsubscribe("pageHeight", handlePageHeightChanged);
          store.unsubscribe("pageWidth", handlePageWidthChanged);
          store.unsubscribe("rotatedPage", handleRotatedPage);
          store.unsubscribe("rotation", handleRotationChanged);
          store.unsubscribe("pagesRotation", handlePagesRotationChanged);
        };
      }, []);
      core.useIsomorphicLayoutEffect(function() {
        store.subscribe("currentPage", handleCurrentPageChanged);
        return function() {
          store.unsubscribe("currentPage", handleCurrentPageChanged);
        };
      }, []);
      return currentDoc ? React__namespace.createElement(
        core.LazyRender,
        { testId: "thumbnail__list-container", attrs: {
          className: "rpv-thumbnail__list-container"
        } },
        React__namespace.createElement(FetchLabels, { doc: currentDoc }, function(labels) {
          return React__namespace.createElement(ThumbnailList, { currentPage, doc: currentDoc, labels, pagesRotation, pageHeight, pageWidth, renderCurrentPageLabel, renderThumbnailItem, rotatedPage, rotation, thumbnailWidth, onJumpToPage: jump, onRotatePage: rotatePage });
        })
      ) : React__namespace.createElement("div", { "data-testid": "thumbnail-list__loader", className: "rpv-thumbnail__loader" }, React__namespace.useContext(SpinnerContext).renderSpinner());
    };
    var thumbnailPlugin = function(pluginProps) {
      var store = React__namespace.useMemo(function() {
        return core.createStore({
          rotatePage: function() {
          }
        });
      }, []);
      var _a = React__namespace.useState(""), docId = _a[0], setDocId = _a[1];
      var CoverDecorator = function(props) {
        return React__namespace.createElement(Cover, __assign({}, props, { renderSpinner: pluginProps === null || pluginProps === void 0 ? void 0 : pluginProps.renderSpinner, store }));
      };
      var ThumbnailsDecorator = React__namespace.useCallback(function(props) {
        return React__namespace.createElement(
          SpinnerContext.Provider,
          { value: { renderSpinner: (pluginProps === null || pluginProps === void 0 ? void 0 : pluginProps.renderSpinner) || defaultSpinner } },
          React__namespace.createElement(ThumbnailListWithStore, { renderCurrentPageLabel: pluginProps === null || pluginProps === void 0 ? void 0 : pluginProps.renderCurrentPageLabel, renderThumbnailItem: props === null || props === void 0 ? void 0 : props.renderThumbnailItem, store, thumbnailWidth: (pluginProps === null || pluginProps === void 0 ? void 0 : pluginProps.thumbnailWidth) || 100 })
        );
      }, [docId]);
      return {
        install: function(pluginFunctions) {
          store.update("jumpToPage", pluginFunctions.jumpToPage);
          store.update("rotatePage", pluginFunctions.rotatePage);
        },
        onDocumentLoad: function(props) {
          setDocId(props.doc.loadingTask.docId);
          store.update("doc", props.doc);
        },
        onViewerStateChange: function(viewerState) {
          store.update("currentPage", viewerState.pageIndex);
          store.update("pagesRotation", viewerState.pagesRotation);
          store.update("pageHeight", viewerState.pageHeight);
          store.update("pageWidth", viewerState.pageWidth);
          store.update("rotation", viewerState.rotation);
          store.update("rotatedPage", viewerState.rotatedPage);
          return viewerState;
        },
        Cover: CoverDecorator,
        Thumbnails: ThumbnailsDecorator
      };
    };
    exports.thumbnailPlugin = thumbnailPlugin;
  }
});

// node_modules/@react-pdf-viewer/thumbnail/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@react-pdf-viewer/thumbnail/lib/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_thumbnail();
    }
  }
});

// node_modules/@react-pdf-viewer/default-layout/lib/cjs/default-layout.js
var require_default_layout = __commonJS({
  "node_modules/@react-pdf-viewer/default-layout/lib/cjs/default-layout.js"(exports) {
    "use strict";
    var core = require_lib();
    var React = require_react();
    var attachment = require_lib3();
    var bookmark = require_lib4();
    var thumbnail = require_lib5();
    var toolbar = require_lib2();
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n.default = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespaceDefault(React);
    var BookmarkIcon = function() {
      return React__namespace.createElement(
        core.Icon,
        { size: 16 },
        React__namespace.createElement("path", { d: "M11.5,1.5h11c0.552,0,1,0.448,1,1v20c0,0.552-0.448,1-1,1h-21c-0.552,0-1-0.448-1-1v-20c0-0.552,0.448-1,1-1h3\n            M11.5,10.5c0,0.55-0.3,0.661-0.659,0.248L8,7.5l-2.844,3.246c-0.363,0.414-0.659,0.3-0.659-0.247v-9c0-0.552,0.448-1,1-1h5\n            c0.552,0,1,0.448,1,1L11.5,10.5z\n            M14.5,6.499h6\n            M14.5,10.499h6\n            M3.5,14.499h17\n            M3.5,18.499h16.497" })
      );
    };
    var __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var FileIcon = function() {
      return React__namespace.createElement(
        core.Icon,
        { size: 16 },
        React__namespace.createElement("path", { d: "M7.618,15.345l8.666-8.666c0.78-0.812,2.071-0.838,2.883-0.058s0.838,2.071,0.058,2.883\n            c-0.019,0.02-0.038,0.039-0.058,0.058L7.461,21.305c-1.593,1.593-4.175,1.592-5.767,0s-1.592-4.175,0-5.767c0,0,0,0,0,0\n            L13.928,3.305c2.189-2.19,5.739-2.19,7.929-0.001s2.19,5.739,0,7.929l0,0L13.192,19.9" })
      );
    };
    var ThumbnailIcon = function() {
      return React__namespace.createElement(
        core.Icon,
        { size: 16 },
        React__namespace.createElement("path", { d: "M10.5,9.5c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V9.5z\n            M23.5,9.5c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V9.5z\n            M10.5,22.5 c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V22.5z\n            M23.5,22.5c0,0.552-0.448,1-1,1 h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V22.5z" })
      );
    };
    var TOOLTIP_OFFSET_LTR = { left: 8, top: 0 };
    var TOOLTIP_OFFSET_RTL = { left: -8, top: 0 };
    var Sidebar = function(_a) {
      var attachmentTabContent = _a.attachmentTabContent, bookmarkTabContent = _a.bookmarkTabContent, store = _a.store, thumbnailTabContent = _a.thumbnailTabContent, tabs = _a.tabs;
      var containerRef = React__namespace.useRef();
      var l10n = React__namespace.useContext(core.LocalizationContext).l10n;
      var _b = React__namespace.useState(store.get("isCurrentTabOpened") || false), opened = _b[0], setOpened = _b[1];
      var _c = React__namespace.useState(Math.max(store.get("currentTab") || 0, 0)), currentTab = _c[0], setCurrentTab = _c[1];
      var direction = React__namespace.useContext(core.ThemeContext).direction;
      var isRtl = direction === core.TextDirection.RightToLeft;
      var resizeConstrain = function(size) {
        return size.firstHalfPercentage >= 20 && size.firstHalfPercentage <= 80;
      };
      var defaultTabs = [
        {
          content: thumbnailTabContent,
          icon: React__namespace.createElement(ThumbnailIcon, null),
          title: l10n && l10n.defaultLayout ? l10n.defaultLayout.thumbnail : "Thumbnail"
        },
        {
          content: bookmarkTabContent,
          icon: React__namespace.createElement(BookmarkIcon, null),
          title: l10n && l10n.defaultLayout ? l10n.defaultLayout.bookmark : "Bookmark"
        },
        {
          content: attachmentTabContent,
          icon: React__namespace.createElement(FileIcon, null),
          title: l10n && l10n.defaultLayout ? l10n.defaultLayout.attachment : "Attachment"
        }
      ];
      var listTabs = tabs ? tabs(defaultTabs) : defaultTabs;
      var toggleTab = function(index) {
        if (currentTab === index) {
          store.update("isCurrentTabOpened", !store.get("isCurrentTabOpened"));
          var container = containerRef.current;
          if (container) {
            var width = container.style.width;
            if (width) {
              container.style.removeProperty("width");
            }
          }
        } else {
          store.update("currentTab", index);
        }
      };
      var switchToTab = function(index) {
        if (index >= 0 && index <= listTabs.length - 1) {
          store.update("isCurrentTabOpened", true);
          setCurrentTab(index);
        }
      };
      var handleCurrentTabOpened = function(opened2) {
        setOpened(opened2);
      };
      React__namespace.useEffect(function() {
        store.subscribe("currentTab", switchToTab);
        store.subscribe("isCurrentTabOpened", handleCurrentTabOpened);
        return function() {
          store.unsubscribe("currentTab", switchToTab);
          store.unsubscribe("isCurrentTabOpened", handleCurrentTabOpened);
        };
      }, []);
      if (listTabs.length === 0) {
        return React__namespace.createElement(React__namespace.Fragment, null);
      }
      return React__namespace.createElement(
        React__namespace.Fragment,
        null,
        React__namespace.createElement(
          "div",
          { "data-testid": "default-layout__sidebar", className: core.classNames({
            "rpv-default-layout__sidebar": true,
            "rpv-default-layout__sidebar--opened": opened,
            "rpv-default-layout__sidebar--ltr": !isRtl,
            "rpv-default-layout__sidebar--rtl": isRtl
          }), ref: containerRef },
          React__namespace.createElement(
            "div",
            { className: "rpv-default-layout__sidebar-tabs" },
            React__namespace.createElement("div", { className: "rpv-default-layout__sidebar-headers", role: "tablist", "aria-orientation": "vertical" }, listTabs.map(function(tab, index) {
              return React__namespace.createElement(
                "div",
                { "aria-controls": "rpv-default-layout__sidebar-content", "aria-selected": currentTab === index, key: index, className: "rpv-default-layout__sidebar-header", id: "rpv-default-layout__sidebar-tab-".concat(index), role: "tab" },
                React__namespace.createElement(core.Tooltip, { ariaControlsSuffix: "default-layout-sidebar-tab-".concat(index), position: isRtl ? core.Position.LeftCenter : core.Position.RightCenter, target: React__namespace.createElement(core.MinimalButton, { ariaLabel: tab.title, isSelected: currentTab === index, onClick: function() {
                  return toggleTab(index);
                } }, tab.icon), content: function() {
                  return tab.title;
                }, offset: isRtl ? TOOLTIP_OFFSET_RTL : TOOLTIP_OFFSET_LTR })
              );
            })),
            React__namespace.createElement("div", { "aria-labelledby": "rpv-default-layout__sidebar-tab-".concat(currentTab), id: "rpv-default-layout__sidebar-content", className: core.classNames({
              "rpv-default-layout__sidebar-content": true,
              "rpv-default-layout__sidebar-content--opened": opened,
              "rpv-default-layout__sidebar-content--ltr": !isRtl,
              "rpv-default-layout__sidebar-content--rtl": isRtl
            }), role: "tabpanel", tabIndex: -1 }, listTabs[currentTab].content)
          )
        ),
        opened && React__namespace.createElement(core.Splitter, { constrain: resizeConstrain })
      );
    };
    var defaultLayoutPlugin = function(props) {
      var store = React__namespace.useMemo(function() {
        return core.createStore({
          isCurrentTabOpened: false,
          currentTab: 0
        });
      }, []);
      var attachmentPluginInstance = attachment.attachmentPlugin();
      var bookmarkPluginInstance = bookmark.bookmarkPlugin();
      var thumbnailPluginInstance = thumbnail.thumbnailPlugin(props ? props.thumbnailPlugin : {});
      var toolbarPluginInstance = toolbar.toolbarPlugin(props ? props.toolbarPlugin : {});
      var Attachments = attachmentPluginInstance.Attachments;
      var Bookmarks = bookmarkPluginInstance.Bookmarks;
      var Thumbnails = thumbnailPluginInstance.Thumbnails;
      var Toolbar = toolbarPluginInstance.Toolbar;
      var sidebarTabs = props ? props.sidebarTabs : function(defaultTabs) {
        return defaultTabs;
      };
      var plugins = [attachmentPluginInstance, bookmarkPluginInstance, thumbnailPluginInstance, toolbarPluginInstance];
      return {
        attachmentPluginInstance,
        bookmarkPluginInstance,
        thumbnailPluginInstance,
        toolbarPluginInstance,
        activateTab: function(index) {
          store.update("currentTab", index);
        },
        toggleTab: function(index) {
          var currentTab = store.get("currentTab");
          store.update("isCurrentTabOpened", !store.get("isCurrentTabOpened"));
          if (currentTab !== index) {
            store.update("currentTab", index);
          }
        },
        install: function(pluginFunctions) {
          plugins.forEach(function(plugin) {
            if (plugin.install) {
              plugin.install(pluginFunctions);
            }
          });
        },
        renderPageLayer: function(renderProps) {
          return React__namespace.createElement(React__namespace.Fragment, null, plugins.map(function(plugin, idx) {
            return plugin.renderPageLayer ? React__namespace.createElement(React__namespace.Fragment, { key: idx }, plugin.renderPageLayer(renderProps)) : React__namespace.createElement(
              React__namespace.Fragment,
              { key: idx },
              React__namespace.createElement(React__namespace.Fragment, null)
            );
          }));
        },
        renderViewer: function(renderProps) {
          var slot = renderProps.slot;
          plugins.forEach(function(plugin) {
            if (plugin.renderViewer) {
              slot = plugin.renderViewer(__assign(__assign({}, renderProps), { slot }));
            }
          });
          var mergeSubSlot = slot.subSlot && slot.subSlot.attrs ? {
            className: slot.subSlot.attrs.className,
            "data-testid": slot.subSlot.attrs["data-testid"],
            ref: slot.subSlot.attrs.ref,
            style: slot.subSlot.attrs.style
          } : {};
          slot.children = React__namespace.createElement(
            "div",
            { className: "rpv-default-layout__container" },
            React__namespace.createElement(
              "div",
              { "data-testid": "default-layout__main", className: core.classNames({
                "rpv-default-layout__main": true,
                "rpv-default-layout__main--rtl": renderProps.themeContext.direction === core.TextDirection.RightToLeft
              }) },
              React__namespace.createElement(Sidebar, { attachmentTabContent: React__namespace.createElement(Attachments, null), bookmarkTabContent: React__namespace.createElement(Bookmarks, null), store, thumbnailTabContent: React__namespace.createElement(Thumbnails, null), tabs: sidebarTabs }),
              React__namespace.createElement(
                "div",
                { className: "rpv-default-layout__body", "data-testid": "default-layout__body" },
                React__namespace.createElement("div", { className: "rpv-default-layout__toolbar" }, props && props.renderToolbar ? props.renderToolbar(Toolbar) : React__namespace.createElement(Toolbar, null)),
                React__namespace.createElement("div", __assign({}, mergeSubSlot), slot.subSlot.children)
              )
            ),
            slot.children
          );
          slot.subSlot.attrs = {};
          slot.subSlot.children = React__namespace.createElement(React__namespace.Fragment, null);
          return slot;
        },
        uninstall: function(pluginFunctions) {
          plugins.forEach(function(plugin) {
            if (plugin.uninstall) {
              plugin.uninstall(pluginFunctions);
            }
          });
        },
        onDocumentLoad: function(documentLoadProps) {
          plugins.forEach(function(plugin) {
            if (plugin.onDocumentLoad) {
              plugin.onDocumentLoad(documentLoadProps);
            }
          });
          if (props && props.setInitialTab) {
            props.setInitialTab(documentLoadProps.doc).then(function(initialTab) {
              store.update("currentTab", initialTab);
              store.update("isCurrentTabOpened", true);
            });
          }
        },
        onAnnotationLayerRender: function(props2) {
          plugins.forEach(function(plugin) {
            if (plugin.onAnnotationLayerRender) {
              plugin.onAnnotationLayerRender(props2);
            }
          });
        },
        onTextLayerRender: function(props2) {
          plugins.forEach(function(plugin) {
            if (plugin.onTextLayerRender) {
              plugin.onTextLayerRender(props2);
            }
          });
        },
        onViewerStateChange: function(viewerState) {
          var newState = viewerState;
          plugins.forEach(function(plugin) {
            if (plugin.onViewerStateChange) {
              newState = plugin.onViewerStateChange(newState);
            }
          });
          return newState;
        }
      };
    };
    var setInitialTabFromPageMode = function(doc) {
      return new Promise(function(resolve, _) {
        doc.getPageMode().then(function(pageMode) {
          if (!pageMode) {
            resolve(-1);
          } else {
            switch (pageMode) {
              case core.PageMode.Attachments:
                resolve(2);
                break;
              case core.PageMode.Bookmarks:
                resolve(1);
                break;
              case core.PageMode.Thumbnails:
                resolve(0);
                break;
              default:
                resolve(-1);
                break;
            }
          }
        });
      });
    };
    exports.BookmarkIcon = BookmarkIcon;
    exports.FileIcon = FileIcon;
    exports.ThumbnailIcon = ThumbnailIcon;
    exports.defaultLayoutPlugin = defaultLayoutPlugin;
    exports.setInitialTabFromPageMode = setInitialTabFromPageMode;
  }
});

// node_modules/@react-pdf-viewer/default-layout/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@react-pdf-viewer/default-layout/lib/index.js"(exports, module) {
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_default_layout();
    }
  }
});
export default require_lib6();
/**
 * A React component to view a PDF document
 *
 * @see https://react-pdf-viewer.dev
 * @license https://react-pdf-viewer.dev/license
 * @copyright 2019-2022 Nguyen Huu Phuoc <me@phuoc.ng>
 */
//# sourceMappingURL=@react-pdf-viewer_default-layout.js.map
